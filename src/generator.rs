use crate::generators::{VanillaTypeScriptGenerator, ZodGenerator};
use crate::models::{CommandInfo, StructInfo};
use std::collections::HashMap;

pub struct TypeScriptGenerator {
    validation_library: String,
}

impl TypeScriptGenerator {
    pub fn new(validation_library: Option<String>) -> Self {
        Self {
            validation_library: validation_library.unwrap_or_else(|| "zod".to_string()),
        }
    }

    pub fn generate_models(
        &mut self,
        commands: &[CommandInfo],
        discovered_structs: &HashMap<String, StructInfo>,
        output_path: &str,
    ) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        match self.validation_library.as_str() {
            "zod" => {
                let mut generator = ZodGenerator::new();
                generator.generate_models(commands, discovered_structs, output_path)
            }
            "none" => {
                let mut generator = VanillaTypeScriptGenerator::new();
                generator.generate_models(commands, discovered_structs, output_path)
            }
            "yup" => {
                // For yup, use vanilla generator but with schemas generation
                let mut generator = VanillaTypeScriptGenerator::new();
                let mut generated_files = generator.generate_models(commands, discovered_structs, output_path)?;
                
                // Generate additional schemas file for yup
                let yup_schemas = self.generate_yup_schemas(commands, output_path)?;
                generated_files.push("schemas.ts".to_string());
                
                Ok(generated_files)
            }
            _ => {
                // For other validation libraries, fall back to vanilla
                let mut generator = VanillaTypeScriptGenerator::new();
                generator.generate_models(commands, discovered_structs, output_path)
            }
        }
    }

    // Helper methods for testing - delegate to appropriate generator
    pub fn to_pascal_case(&self, s: &str) -> String {
        match self.validation_library.as_str() {
            "zod" => {
                let generator = ZodGenerator::new();
                generator.to_pascal_case(s)
            }
            _ => {
                let generator = VanillaTypeScriptGenerator::new();
                generator.to_pascal_case(s)
            }
        }
    }

    pub fn to_camel_case(&self, s: &str) -> String {
        match self.validation_library.as_str() {
            "zod" => {
                let generator = ZodGenerator::new();
                generator.to_camel_case(s)
            }
            _ => {
                let generator = VanillaTypeScriptGenerator::new();
                generator.to_camel_case(s)
            }
        }
    }

    pub fn collect_referenced_types(&self, rust_type: &str, used_types: &mut std::collections::HashSet<String>) {
        match self.validation_library.as_str() {
            "zod" => {
                let generator = ZodGenerator::new();
                generator.collect_referenced_types(rust_type, used_types)
            }
            _ => {
                let generator = VanillaTypeScriptGenerator::new();
                generator.collect_referenced_types(rust_type, used_types)
            }
        }
    }

    pub fn typescript_to_zod_type(&self, ts_type: &str) -> String {
        let generator = ZodGenerator::new();
        generator.typescript_to_zod_type(ts_type)
    }

    pub fn typescript_to_yup_type(&self, ts_type: &str) -> String {
        self.typescript_to_yup_type_impl(ts_type)
    }

    fn generate_yup_schemas(
        &self,
        commands: &[CommandInfo],
        output_path: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut content = String::new();

        content.push_str(&format!(
            "/**\n * Auto-generated validation schemas for Tauri commands\n * Generated by tauri-plugin-typegen\n * Do not edit manually - regenerate using: cargo tauri-typegen generate\n */\n\n"
        ));

        content.push_str("import * as yup from 'yup';\n\n");

        for command in commands {
            if !command.parameters.is_empty() {
                let schema = self.generate_yup_schema(command);
                content.push_str(&schema);
                content.push_str("\n");
            }
        }

        let schemas_file_path = format!("{}/schemas.ts", output_path);
        std::fs::write(&schemas_file_path, content)?;
        
        Ok(())
    }

    fn generate_yup_schema(&self, command: &CommandInfo) -> String {
        let schema_name = format!("{}ParamsSchema", self.to_pascal_case(&command.name));
        let mut content = format!("export const {} = yup.object({{\n", schema_name);

        for param in &command.parameters {
            let param_name = self.to_camel_case(&param.name);
            let yup_type = self.typescript_to_yup_type_impl(&param.typescript_type);
            content.push_str(&format!("  {}: {},\n", param_name, yup_type));
        }

        content.push_str("});\n");
        content
    }

    fn typescript_to_yup_type_impl(&self, ts_type: &str) -> String {
        if ts_type.contains(" | null") {
            let base_type = ts_type.replace(" | null", "");
            return format!("{}.nullable()", self.typescript_to_yup_type_impl(&base_type));
        }

        if ts_type.ends_with("[]") {
            let item_type = &ts_type[..ts_type.len() - 2];
            return format!("yup.array().of({})", self.typescript_to_yup_type_impl(item_type));
        }
        
        // Handle Record<K, V> types (from HashMap/BTreeMap)
        if ts_type.starts_with("Record<") {
            if let Some(inner) = ts_type.strip_prefix("Record<").and_then(|s| s.strip_suffix(">")) {
                if let Some(comma_pos) = inner.find(',') {
                    let value_type = inner[comma_pos + 1..].trim();
                    let value_schema = self.typescript_to_yup_type_impl(value_type);
                    return format!("yup.object().test('record', 'Invalid record', (value) => {{ if (!value) return true; return Object.values(value).every(v => {}.isValidSync(v)); }})", value_schema);
                }
            }
            return "yup.object()".to_string();
        }
        
        // Handle tuple types [T, U, V]
        if ts_type.starts_with('[') && ts_type.ends_with(']') {
            let inner = &ts_type[1..ts_type.len()-1];
            let types: Vec<String> = inner
                .split(',')
                .map(|part| self.typescript_to_yup_type_impl(part.trim()))
                .collect();
            return format!("yup.tuple([{}])", types.join(", "));
        }

        match ts_type {
            "string" => "yup.string()".to_string(),
            "number" => "yup.number()".to_string(),
            "boolean" => "yup.boolean()".to_string(),
            "void" => "yup.mixed()".to_string(),
            _ => "yup.mixed()".to_string(), // Custom types
        }
    }

    pub fn is_custom_type(&self, ts_type: &str) -> bool {
        match self.validation_library.as_str() {
            "zod" => {
                let generator = ZodGenerator::new();
                generator.is_custom_type(ts_type)
            }
            _ => {
                let generator = VanillaTypeScriptGenerator::new();
                generator.is_custom_type(ts_type)
            }
        }
    }
}
