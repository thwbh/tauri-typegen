use crate::analysis::CommandAnalyzer;
use crate::generators::base::file_writer::FileWriter;
use crate::generators::base::template_context::{CommandContext, EventContext, FieldContext};
use crate::generators::base::templates::GlobalContext;
use crate::generators::base::type_conversion::TypeConverter;
use crate::generators::base::type_visitor::TypeScriptVisitor;
use crate::generators::base::{BaseBindingsGenerator, BaseGenerator};
use crate::models::{CommandInfo, EventInfo, StructInfo};
use std::collections::{HashMap, HashSet};
use tera::{Context, Tera};

/// Generator for vanilla TypeScript bindings without validation
pub struct TypeScriptBindingsGenerator {
    base: BaseGenerator,
    type_converter: TypeConverter,
    tera: Tera,
}

impl TypeScriptBindingsGenerator {
    pub fn new() -> Self {
        Self {
            base: BaseGenerator::new(),
            type_converter: TypeConverter::new(),
            tera: super::templates::create_template_engine()
                .expect("Failed to initialize TypeScript template engine"),
        }
    }

    /// Generate file header using templates
    fn generate_file_header(&self) -> String {
        let global_context = GlobalContext::new("typescript");
        let mut context = Context::new();
        context.insert("global", &global_context);

        super::templates::render(&self.tera, "common/header.tera", &context)
            .unwrap_or_else(|e| {
                eprintln!("Failed to render header template: {}", e);
                // Fallback to simple header
                let version = env!("CARGO_PKG_VERSION");
                let timestamp = chrono::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Secs, true);
                format!(
                    "/**\n * Auto-generated TypeScript bindings for Tauri commands\n * Generated by tauri-typegen v{}\n * Generated at: {}\n * Generator: typescript\n *\n * Do not edit manually - regenerate using: cargo tauri-typegen generate\n */\n\n",
                    version, timestamp
                )
            })
    }

    /// Generate TypeScript interface definitions from structs
    fn generate_struct_interfaces(&self, used_structs: &HashMap<String, StructInfo>) -> String {
        let mut content = String::new();
        let visitor = TypeScriptVisitor;

        for (name, struct_info) in used_structs {
            // Convert FieldInfo to FieldContext with computed TypeScript types
            let field_contexts: Vec<FieldContext> = struct_info
                .fields
                .iter()
                .map(|field| FieldContext::from_field_info(field, &visitor))
                .collect();

            let mut context = Context::new();
            context.insert("name", name);
            context.insert("fields", &field_contexts);

            let template_name = if struct_info.is_enum {
                "typescript/partials/enum.tera"
            } else {
                "typescript/partials/interface.tera"
            };

            if let Ok(rendered) = super::templates::render(&self.tera, template_name, &context) {
                content.push_str(&rendered);
                content.push('\n');
            }
        }

        content
    }

    /// Generate parameter interfaces for commands
    fn generate_param_interfaces(
        &self,
        commands: &[CommandInfo],
        analyzer: &CommandAnalyzer,
    ) -> String {
        let mut content = String::new();
        let visitor = TypeScriptVisitor;
        let type_resolver = analyzer.get_type_resolver();

        for command in commands {
            // Generate interface if command has parameters or channels
            if !command.parameters.is_empty() || !command.channels.is_empty() {
                let command_context =
                    CommandContext::from_command_info(command, &visitor, &|rust_type: &str| {
                        type_resolver.borrow_mut().parse_type_structure(rust_type)
                    });

                let mut context = Context::new();
                context.insert("command", &command_context);

                if let Ok(rendered) = super::templates::render(
                    &self.tera,
                    "typescript/partials/param_interface.ts.tera",
                    &context,
                ) {
                    content.push_str(&rendered);
                }
            }
        }

        content
    }

    /// Generate the complete types.ts file content
    fn generate_types_file_content(
        &self,
        commands: &[CommandInfo],
        used_structs: &HashMap<String, StructInfo>,
        analyzer: &CommandAnalyzer,
    ) -> String {
        let has_channels = commands.iter().any(|cmd| !cmd.channels.is_empty());

        // Generate parameter interfaces
        let param_interfaces = self.generate_param_interfaces(commands, analyzer);

        // Generate struct interfaces
        let struct_interfaces = self.generate_struct_interfaces(used_structs);

        // Render main types.ts template
        let mut context = Context::new();
        context.insert("header", &self.generate_file_header());
        context.insert("has_channels", &has_channels);
        context.insert("param_interfaces", &param_interfaces);
        context.insert("struct_interfaces", &struct_interfaces);

        super::templates::render(&self.tera, "typescript/types.ts.tera", &context).unwrap_or_else(
            |e| {
                eprintln!("Template rendering failed for types.ts: {}", e);
                String::new()
            },
        )
    }

    /// Generate command bindings
    fn generate_command_bindings(
        &self,
        commands: &[CommandInfo],
        analyzer: &CommandAnalyzer,
    ) -> String {
        let has_channels = commands.iter().any(|cmd| !cmd.channels.is_empty());
        let visitor = TypeScriptVisitor;
        let type_resolver = analyzer.get_type_resolver();

        // Convert commands to context wrappers
        let command_contexts: Vec<CommandContext> = commands
            .iter()
            .map(|cmd| {
                CommandContext::from_command_info(cmd, &visitor, &|rust_type: &str| {
                    type_resolver.borrow_mut().parse_type_structure(rust_type)
                })
            })
            .collect();

        let mut context = Context::new();
        context.insert("header", &self.generate_file_header());
        context.insert("commands", &command_contexts);
        context.insert("has_channels", &has_channels);

        super::templates::render(&self.tera, "typescript/commands.ts.tera", &context)
            .unwrap_or_else(|e| {
                eprintln!("Template rendering failed for commands.ts: {}", e);
                String::new()
            })
    }

    /// Generate index.ts file
    fn generate_index_file(&self, generated_files: &[String]) -> String {
        let mut context = Context::new();
        context.insert("header", &self.generate_file_header());
        context.insert("files", generated_files);

        super::templates::render(&self.tera, "typescript/index.ts.tera", &context).unwrap_or_else(
            |e| {
                eprintln!("Template rendering failed for index.ts: {}", e);
                String::new()
            },
        )
    }

    /// Collect referenced types for backward compatibility
    pub fn collect_referenced_types(&self, rust_type: &str, used_types: &mut HashSet<String>) {
        self.type_converter
            .collect_referenced_types(rust_type, used_types);
    }

    /// Check if a type is custom for backward compatibility  
    pub fn is_custom_type(&self, type_name: &str) -> bool {
        // Check if it's in known types or looks like a custom type
        self.type_converter.is_custom_type(type_name) || self.looks_like_custom_type(type_name)
    }

    /// Check if a type looks like a custom type (starts with capital letter, not a primitive)
    fn looks_like_custom_type(&self, ts_type: &str) -> bool {
        // Must start with a capital letter
        if !ts_type
            .chars()
            .next()
            .map(|c| c.is_ascii_uppercase())
            .unwrap_or(false)
        {
            return false;
        }

        // Must not be a primitive type
        !self.type_converter.is_primitive_type(ts_type)
    }

    /// Generate events file content
    fn generate_events_file(&self, events: &[EventInfo], analyzer: &CommandAnalyzer) -> String {
        let visitor = TypeScriptVisitor;
        let type_resolver = analyzer.get_type_resolver();

        // Convert events to context wrappers
        let event_contexts: Vec<EventContext> = events
            .iter()
            .map(|event| {
                EventContext::from_event_info(event, &visitor, &|rust_type: &str| {
                    type_resolver.borrow_mut().parse_type_structure(rust_type)
                })
            })
            .collect();

        // Collect unique payload types for imports
        let mut payload_types: HashSet<String> = HashSet::new();
        for event_ctx in &event_contexts {
            // Extract the TypeScript type name (without generics, arrays, etc.)
            let type_name = event_ctx
                .typescript_payload_type
                .split('<')
                .next()
                .unwrap_or(&event_ctx.typescript_payload_type);
            let type_name = type_name.split('[').next().unwrap_or(type_name);
            let type_name = type_name.trim();

            // Only import if it's not a primitive type
            if !matches!(
                type_name,
                "string" | "number" | "boolean" | "void" | "null" | "undefined"
            ) {
                payload_types.insert(type_name.to_string());
            }
        }

        let mut context = Context::new();
        context.insert("header", &self.generate_file_header());
        context.insert("events", &event_contexts);
        context.insert(
            "payload_types",
            &payload_types.into_iter().collect::<Vec<_>>(),
        );

        super::templates::render(&self.tera, "typescript/events.ts.tera", &context).unwrap_or_else(
            |e| {
                eprintln!("Template rendering failed for events.ts: {}", e);
                String::new()
            },
        )
    }
}

impl BaseBindingsGenerator for TypeScriptBindingsGenerator {
    fn generate_models(
        &mut self,
        commands: &[CommandInfo],
        discovered_structs: &HashMap<String, StructInfo>,
        output_path: &str,
        analyzer: &CommandAnalyzer,
    ) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        // Set up the type converter with known structs
        self.type_converter
            .set_known_types(discovered_structs.clone());

        // Store known structs for reference
        self.base.known_structs = discovered_structs.clone();

        // Filter to only the types used by commands
        let mut used_structs = self.base.collect_used_types(commands, discovered_structs);

        // Also collect types used in events
        let events = analyzer.get_discovered_events();

        for event in events {
            let mut event_types = std::collections::HashSet::new();
            self.base
                .collect_referenced_types(&event.payload_type, &mut event_types);

            // Add event payload types to used_structs
            for type_name in event_types {
                if let Some(struct_info) = discovered_structs.get(&type_name) {
                    used_structs.insert(type_name.clone(), struct_info.clone());
                }
            }
        }

        // Create file writer
        let mut file_writer = FileWriter::new(output_path)?;

        // Generate and write types file
        let types_content = self.generate_types_file_content(commands, &used_structs, analyzer);
        file_writer.write_types_file(&types_content)?;

        // Generate and write commands file
        let commands_content = self.generate_command_bindings(commands, analyzer);
        file_writer.write_commands_file(&commands_content)?;

        // Generate and write events file if there are any events
        let events = analyzer.get_discovered_events();
        if !events.is_empty() {
            let events_content = self.generate_events_file(events, analyzer);
            file_writer.write_events_file(&events_content)?;
        }

        // Generate and write index file
        let index_content = self.generate_index_file(file_writer.get_generated_files());
        file_writer.write_index_file(&index_content)?;

        Ok(file_writer.get_generated_files().to_vec())
    }
}

impl Default for TypeScriptBindingsGenerator {
    fn default() -> Self {
        Self::new()
    }
}
