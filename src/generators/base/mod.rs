pub mod file_writer;
pub mod template_context;
pub mod templates;
pub mod type_visitor;

use tera::{Context, Tera};

use crate::analysis::CommandAnalyzer;
use crate::generators::{GlobalContext, TypeCollector};
use crate::models::{CommandInfo, StructInfo};
use crate::GenerateConfig;
use std::collections::HashMap;

/// Common trait for all generators
pub trait BaseBindingsGenerator {
    /// Template engine for this generator
    fn tera(&self) -> &Tera;

    /// Type collector for this generator
    fn type_collector(&self) -> &TypeCollector;

    /// String representation of the chosen validator
    fn generator_type(&self) -> String;

    /// Generate models from Rust commands and structs
    fn generate_models(
        &mut self,
        commands: &[CommandInfo],
        discovered_structs: &HashMap<String, StructInfo>,
        output_path: &str,
        analyzer: &CommandAnalyzer,
        config: &GenerateConfig,
    ) -> Result<Vec<String>, Box<dyn std::error::Error>>;

    /// Base method for generating the default file header
    fn generate_file_header(&self) -> String {
        let global_context = GlobalContext::new(&self.generator_type());
        let mut context = Context::new();
        context.insert("global", &global_context);

        self.render(
              "common/header.tera",
              &context
          ).unwrap_or_else(|e| {
              eprintln!("Failed to render header template: {}", e);
              // Fallback to simple header
              let version = env!("CARGO_PKG_VERSION");
              let timestamp = chrono::Utc::now()
                  .to_rfc3339_opts(chrono::SecondsFormat::Secs, true);
              format!(
                  "/**\n * Auto-generated bindings\n * Generated by tauri-typegen v{}\n * Generated at: {}\n * Generator: {}\n */\n\n",
                  version, timestamp, self.generator_type()
              )
          })
    }

    /// Render a template with the given context
    fn render(&self, template_name: &str, context: &Context) -> Result<String, String> {
        self.tera().render(template_name, context).map_err(|e| {
            // Get more detailed error information
            let mut error_msg = format!("Failed to render template '{}': {}", template_name, e);

            // Check if there's a source error
            if let Some(source) = std::error::Error::source(&e) {
                error_msg.push_str(&format!("\nSource: {}", source));
            }

            error_msg
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tera::Tera;

    // Mock implementation of BaseBindingsGenerator for testing
    struct MockGenerator {
        tera: Tera,
        type_collector: TypeCollector,
    }

    impl MockGenerator {
        fn new() -> Self {
            let mut tera = Tera::default();
            // Add a simple test template
            tera.add_raw_template(
                "common/header.tera",
                "/* Generated by {{ global.generator_name }} */",
            )
            .unwrap();
            tera.add_raw_template("test.tera", "Hello {{ name }}!")
                .unwrap();

            Self {
                tera,
                type_collector: TypeCollector::new(),
            }
        }
    }

    impl BaseBindingsGenerator for MockGenerator {
        fn tera(&self) -> &Tera {
            &self.tera
        }

        fn type_collector(&self) -> &TypeCollector {
            &self.type_collector
        }

        fn generator_type(&self) -> String {
            "mock".to_string()
        }

        fn generate_models(
            &mut self,
            _commands: &[CommandInfo],
            _discovered_structs: &HashMap<String, StructInfo>,
            _output_path: &str,
            _analyzer: &CommandAnalyzer,
            _config: &GenerateConfig,
        ) -> Result<Vec<String>, Box<dyn std::error::Error>> {
            Ok(vec!["test.ts".to_string()])
        }
    }

    #[test]
    fn test_generate_file_header_success() {
        let generator = MockGenerator::new();
        let header = generator.generate_file_header();

        assert!(header.contains("Generated by mock"));
    }

    #[test]
    fn test_generate_file_header_fallback() {
        // Create a generator with no header template
        let mut tera = Tera::default();
        tera.add_raw_template("test.tera", "Hello {{ name }}!")
            .unwrap();

        let generator = MockGenerator {
            tera,
            type_collector: TypeCollector::new(),
        };

        let header = generator.generate_file_header();

        // Should fall back to simple header
        assert!(header.contains("Auto-generated bindings"));
        assert!(header.contains("Generated by tauri-typegen"));
        assert!(header.contains("Generator: mock"));
    }

    #[test]
    fn test_render_success() {
        let generator = MockGenerator::new();
        let mut context = Context::new();
        context.insert("name", "World");

        let result = generator.render("test.tera", &context);

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "Hello World!");
    }

    #[test]
    fn test_render_missing_template() {
        let generator = MockGenerator::new();
        let context = Context::new();

        let result = generator.render("nonexistent.tera", &context);

        assert!(result.is_err());
        let error = result.unwrap_err();
        assert!(error.contains("Failed to render template 'nonexistent.tera'"));
    }

    #[test]
    fn test_render_missing_context_variable() {
        let mut tera = Tera::default();
        // Template with strict mode that requires variables
        tera.add_raw_template("strict.tera", "Hello!").unwrap();

        let generator = MockGenerator {
            tera,
            type_collector: TypeCollector::new(),
        };
        let context = Context::new();

        let result = generator.render("strict.tera", &context);

        // Tera allows missing variables by default, so this should succeed
        assert!(result.is_ok());
    }

    #[test]
    fn test_generator_type() {
        let generator = MockGenerator::new();
        assert_eq!(generator.generator_type(), "mock");
    }

    #[test]
    fn test_tera_accessor() {
        let generator = MockGenerator::new();
        let tera = generator.tera();
        assert!(tera.get_template_names().any(|n| n == "test.tera"));
    }

    #[test]
    fn test_type_collector_accessor() {
        let generator = MockGenerator::new();
        let collector = generator.type_collector();
        // TypeCollector doesn't have a get_types method, just verify we can access it
        let _ = collector;
    }

    #[test]
    fn test_generate_models_mock() {
        let mut generator = MockGenerator::new();
        let commands = vec![];
        let structs = HashMap::new();
        let config = GenerateConfig::default();
        let analyzer = CommandAnalyzer::new();

        let result = generator.generate_models(&commands, &structs, ".", &analyzer, &config);

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), vec!["test.ts"]);
    }

    #[test]
    fn test_render_with_complex_context() {
        let mut tera = Tera::default();
        tera.add_raw_template(
            "complex.tera",
            "{{ global.generator_name }} - {{ global.version }}",
        )
        .unwrap();

        let generator = MockGenerator {
            tera,
            type_collector: TypeCollector::new(),
        };

        let global_context = GlobalContext::new(&generator.generator_type());
        let mut context = Context::new();
        context.insert("global", &global_context);

        let result = generator.render("complex.tera", &context);

        assert!(result.is_ok());
        let rendered = result.unwrap();
        assert!(rendered.contains("mock"));
        assert!(rendered.contains(env!("CARGO_PKG_VERSION")));
    }

    #[test]
    fn test_header_contains_version() {
        let generator = MockGenerator::new();
        let header = generator.generate_file_header();

        // Header should contain generator type
        assert!(header.contains("mock"));
    }

    #[test]
    fn test_fallback_header_format() {
        let tera = Tera::default(); // No templates

        let generator = MockGenerator {
            tera,
            type_collector: TypeCollector::new(),
        };

        let header = generator.generate_file_header();

        // Check fallback header structure
        assert!(header.starts_with("/**"));
        assert!(header.contains("Auto-generated bindings"));
        assert!(header.contains("Generated by tauri-typegen"));
        assert!(header.contains("Generator: mock"));
        assert!(header.ends_with("*/\n\n"));
    }
}
