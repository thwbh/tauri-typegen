pub mod file_writer;
pub mod template_helpers;
pub mod type_conversion;

use crate::analysis::CommandAnalyzer;
use crate::models::{CommandInfo, StructInfo};
use std::collections::HashMap;

/// Common trait for all generators
pub trait BaseBindingsGenerator {
    /// Generate models from Rust commands and structs
    fn generate_models(
        &mut self,
        commands: &[CommandInfo],
        discovered_structs: &HashMap<String, StructInfo>,
        output_path: &str,
        analyzer: &CommandAnalyzer,
    ) -> Result<Vec<String>, Box<dyn std::error::Error>>;

    /// Convert a string to PascalCase
    fn to_pascal_case(&self, s: &str) -> String {
        s.split('_')
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => {
                        first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase()
                    }
                }
            })
            .collect()
    }

    /// Generate file header comment
    fn generate_file_header(&self) -> String {
        "/**
 * Auto-generated TypeScript types for Tauri commands
 * Generated by tauri-plugin-typegen
 * Do not edit manually - regenerate using: cargo tauri-typegen generate
 */

"
        .to_string()
    }

    /// Generate command bindings file header
    fn generate_command_file_header(&self) -> String {
        "/**
 * Auto-generated command bindings for Tauri commands
 * Generated by tauri-plugin-typegen
 * Do not edit manually - regenerate using: cargo tauri-typegen generate
 */

"
        .to_string()
    }

    /// Generate index file header
    fn generate_index_file_header(&self) -> String {
        "/**
 * Auto-generated TypeScript bindings for Tauri commands
 * Generated by tauri-plugin-typegen
 * Do not edit manually - regenerate using: cargo tauri-typegen generate
 */

"
        .to_string()
    }
}

/// Base generator with common functionality
pub struct BaseGenerator {
    pub known_structs: HashMap<String, StructInfo>,
}

impl BaseGenerator {
    pub fn new() -> Self {
        Self {
            known_structs: HashMap::new(),
        }
    }

    /// Filter only the types used by commands
    pub fn collect_used_types(
        &self,
        commands: &[CommandInfo],
        all_structs: &HashMap<String, StructInfo>,
    ) -> HashMap<String, StructInfo> {
        let mut used_types = std::collections::HashSet::new();

        // Collect types from commands
        for command in commands {
            // Add parameter types
            for param in &command.parameters {
                self.collect_referenced_types(&param.rust_type, &mut used_types);
            }
            // Add return type
            self.collect_referenced_types(&command.return_type, &mut used_types);
        }

        // Recursively collect nested dependencies from struct fields
        let mut types_to_process: Vec<String> = used_types.iter().cloned().collect();
        let mut processed_types = std::collections::HashSet::new();

        while let Some(type_name) = types_to_process.pop() {
            if processed_types.contains(&type_name) {
                continue;
            }
            processed_types.insert(type_name.clone());

            // If this type is a known struct, collect types from its fields
            if let Some(struct_info) = all_structs.get(&type_name) {
                for field in &struct_info.fields {
                    let mut field_types = std::collections::HashSet::new();
                    self.collect_referenced_types(&field.rust_type, &mut field_types);
                    
                    for field_type in field_types {
                        if !used_types.contains(&field_type) {
                            used_types.insert(field_type.clone());
                            types_to_process.push(field_type);
                        }
                    }
                }
            }
        }

        // Filter to only include used types
        all_structs
            .iter()
            .filter(|(name, _)| used_types.contains(*name))
            .map(|(k, v)| (k.clone(), v.clone()))
            .collect()
    }

    /// Recursively collect type names from complex types
    pub fn collect_referenced_types(
        &self,
        type_str: &str,
        used_types: &mut std::collections::HashSet<String>,
    ) {
        let cleaned_type = type_str.trim();
        
        // Handle Result<T, E> - need to extract both types
        if let Some((ok_type, err_type)) = self.extract_result_both_types(cleaned_type) {
            self.collect_referenced_types(&ok_type, used_types);
            self.collect_referenced_types(&err_type, used_types);
            return;
        }

        // Handle Option<T>
        if let Some(inner) = self.extract_option_inner_type(cleaned_type) {
            self.collect_referenced_types(&inner, used_types);
            return;
        }

        // Handle Vec<T>
        if let Some(inner) = self.extract_vec_inner_type(cleaned_type) {
            self.collect_referenced_types(&inner, used_types);
            return;
        }

        // Handle HashMap<K, V>
        if let Some((key_type, value_type)) = self.extract_hashmap_types(cleaned_type) {
            self.collect_referenced_types(&key_type, used_types);
            self.collect_referenced_types(&value_type, used_types);
            return;
        }

        // Handle tuples (T1, T2, ...)
        if let Some(tuple_types) = self.extract_tuple_types(cleaned_type) {
            for tuple_type in tuple_types {
                self.collect_referenced_types(&tuple_type, used_types);
            }
            return;
        }

        // Handle references &T
        if cleaned_type.starts_with('&') {
            let inner = cleaned_type.trim_start_matches('&').trim();
            self.collect_referenced_types(inner, used_types);
            return;
        }

        // If it's not a primitive type, add it to used types
        if !self.is_primitive_type(cleaned_type) {
            used_types.insert(cleaned_type.to_string());
        }
    }

    fn extract_result_both_types(&self, type_str: &str) -> Option<(String, String)> {
        if type_str.starts_with("Result<") && type_str.ends_with('>') {
            let inner = &type_str[7..type_str.len() - 1];
            if let Some(comma_pos) = self.find_top_level_comma(inner) {
                let ok_type = inner[..comma_pos].trim().to_string();
                let err_type = inner[comma_pos + 1..].trim().to_string();
                Some((ok_type, err_type))
            } else {
                None
            }
        } else {
            None
        }
    }

    fn extract_hashmap_types(&self, type_str: &str) -> Option<(String, String)> {
        if type_str.starts_with("HashMap<") && type_str.ends_with('>') {
            let inner = &type_str[8..type_str.len() - 1];
            if let Some(comma_pos) = self.find_top_level_comma(inner) {
                let key_type = inner[..comma_pos].trim().to_string();
                let value_type = inner[comma_pos + 1..].trim().to_string();
                Some((key_type, value_type))
            } else {
                None
            }
        } else {
            None
        }
    }

    /// Find the position of a comma that's at the same bracket nesting level (not inside nested generics)
    fn find_top_level_comma(&self, s: &str) -> Option<usize> {
        let mut bracket_depth = 0;
        let mut paren_depth = 0;
        
        for (i, c) in s.char_indices() {
            match c {
                '<' => bracket_depth += 1,
                '>' => bracket_depth -= 1,
                '(' => paren_depth += 1,
                ')' => paren_depth -= 1,
                ',' if bracket_depth == 0 && paren_depth == 0 => return Some(i),
                _ => {}
            }
        }
        None
    }

    fn extract_tuple_types(&self, type_str: &str) -> Option<Vec<String>> {
        if type_str.starts_with('(') && type_str.ends_with(')') {
            let inner = &type_str[1..type_str.len() - 1];
            let types = self.split_by_top_level_comma(inner);
            if types.len() > 1 {
                Some(types)
            } else {
                None
            }
        } else {
            None
        }
    }

    /// Split a string by commas that are at the same bracket nesting level
    fn split_by_top_level_comma(&self, s: &str) -> Vec<String> {
        let mut result = Vec::new();
        let mut bracket_depth = 0;
        let mut paren_depth = 0;
        let mut start = 0;
        
        for (i, c) in s.char_indices() {
            match c {
                '<' => bracket_depth += 1,
                '>' => bracket_depth -= 1,
                '(' => paren_depth += 1,
                ')' => paren_depth -= 1,
                ',' if bracket_depth == 0 && paren_depth == 0 => {
                    result.push(s[start..i].trim().to_string());
                    start = i + 1;
                }
                _ => {}
            }
        }
        
        // Add the last part
        result.push(s[start..].trim().to_string());
        result
    }

    fn extract_option_inner_type(&self, type_str: &str) -> Option<String> {
        if type_str.starts_with("Option<") && type_str.ends_with('>') {
            let inner = &type_str[7..type_str.len() - 1];
            Some(inner.trim().to_string())
        } else {
            None
        }
    }

    fn extract_vec_inner_type(&self, type_str: &str) -> Option<String> {
        if type_str.starts_with("Vec<") && type_str.ends_with('>') {
            let inner = &type_str[4..type_str.len() - 1];
            Some(inner.trim().to_string())
        } else {
            None
        }
    }

    fn is_primitive_type(&self, type_str: &str) -> bool {
        matches!(
            type_str,
            "String"
                | "str"
                | "&str"
                | "i8"
                | "i16"
                | "i32"
                | "i64"
                | "i128"
                | "isize"
                | "u8"
                | "u16"
                | "u32"
                | "u64"
                | "u128"
                | "usize"
                | "f32"
                | "f64"
                | "bool"
                | "()"
                | "number"
                | "string"
                | "boolean"
                | "void"
        )
    }
}

impl Default for BaseGenerator {
    fn default() -> Self {
        Self::new()
    }
}
