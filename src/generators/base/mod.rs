pub mod file_writer;
pub mod template_context;
pub mod templates;
pub mod type_visitor;

use tera::{Context, Tera};

use crate::analysis::CommandAnalyzer;
use crate::generators::{GlobalContext, TypeCollector};
use crate::models::{CommandInfo, StructInfo};
use std::collections::HashMap;

/// Common trait for all generators
pub trait BaseBindingsGenerator {
    /// Template engine for this generator
    fn tera(&self) -> &Tera;

    /// Type collector for this generator
    fn type_collector(&self) -> &TypeCollector;

    /// String representation of the chosen validator
    fn generator_type(&self) -> String;

    /// Generate models from Rust commands and structs
    fn generate_models(
        &mut self,
        commands: &[CommandInfo],
        discovered_structs: &HashMap<String, StructInfo>,
        output_path: &str,
        analyzer: &CommandAnalyzer,
    ) -> Result<Vec<String>, Box<dyn std::error::Error>>;

    /// Base method for generating the default file header
    fn generate_file_header(&self) -> String {
        let global_context = GlobalContext::new(&self.generator_type());
        let mut context = Context::new();
        context.insert("global", &global_context);

        self.render(
              "common/header.tera",
              &context
          ).unwrap_or_else(|e| {
              eprintln!("Failed to render header template: {}", e);
              // Fallback to simple header
              let version = env!("CARGO_PKG_VERSION");
              let timestamp = chrono::Utc::now()
                  .to_rfc3339_opts(chrono::SecondsFormat::Secs, true);
              format!(
                  "/**\n * Auto-generated bindings\n * Generated by tauri-typegen v{}\n * Generated at: {}\n * Generator: {}\n */\n\n",
                  version, timestamp, self.generator_type()
              )
          })
    }

    /// Render a template with the given context
    fn render(&self, template_name: &str, context: &Context) -> Result<String, String> {
        self.tera().render(template_name, context).map_err(|e| {
            // Get more detailed error information
            let mut error_msg = format!("Failed to render template '{}': {}", template_name, e);

            // Check if there's a source error
            if let Some(source) = std::error::Error::source(&e) {
                error_msg.push_str(&format!("\nSource: {}", source));
            }

            error_msg
        })
    }
}
