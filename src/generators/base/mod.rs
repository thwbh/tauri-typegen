pub mod file_writer;
pub mod type_conversion;
pub mod template_helpers;

use crate::analysis::CommandAnalyzer;
use crate::models::{CommandInfo, StructInfo};
use std::collections::HashMap;

/// Common trait for all generators
pub trait BaseBindingsGenerator {
    /// Generate models from Rust commands and structs
    fn generate_models(
        &mut self,
        commands: &[CommandInfo],
        discovered_structs: &HashMap<String, StructInfo>,
        output_path: &str,
        analyzer: &CommandAnalyzer,
    ) -> Result<Vec<String>, Box<dyn std::error::Error>>;

    /// Convert a string to PascalCase
    fn to_pascal_case(&self, s: &str) -> String {
        s.split('_')
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase(),
                }
            })
            .collect()
    }

    /// Generate file header comment
    fn generate_file_header(&self) -> String {
        "/**
 * Auto-generated TypeScript types for Tauri commands
 * Generated by tauri-plugin-typegen
 * Do not edit manually - regenerate using: cargo tauri-typegen generate
 */

".to_string()
    }

    /// Generate command bindings file header
    fn generate_command_file_header(&self) -> String {
        "/**
 * Auto-generated command bindings for Tauri commands
 * Generated by tauri-plugin-typegen
 * Do not edit manually - regenerate using: cargo tauri-typegen generate
 */

".to_string()
    }

    /// Generate index file header
    fn generate_index_file_header(&self) -> String {
        "/**
 * Auto-generated TypeScript bindings for Tauri commands
 * Generated by tauri-plugin-typegen
 * Do not edit manually - regenerate using: cargo tauri-typegen generate
 */

".to_string()
    }
}

/// Base generator with common functionality
pub struct BaseGenerator {
    pub known_structs: HashMap<String, StructInfo>,
}

impl BaseGenerator {
    pub fn new() -> Self {
        Self {
            known_structs: HashMap::new(),
        }
    }

    /// Filter only the types used by commands
    pub fn collect_used_types(
        &self,
        commands: &[CommandInfo],
        all_structs: &HashMap<String, StructInfo>,
    ) -> HashMap<String, StructInfo> {
        let mut used_types = std::collections::HashSet::new();

        // Collect types from commands
        for command in commands {
            // Add parameter types
            for param in &command.parameters {
                self.collect_referenced_types(&param.rust_type, &mut used_types);
            }
            // Add return type
            self.collect_referenced_types(&command.return_type, &mut used_types);
        }

        // Filter to only include used types
        all_structs
            .iter()
            .filter(|(name, _)| used_types.contains(*name))
            .map(|(k, v)| (k.clone(), v.clone()))
            .collect()
    }

    /// Recursively collect type names from complex types
    pub fn collect_referenced_types(&self, type_str: &str, used_types: &mut std::collections::HashSet<String>) {
        // Handle Result<T, E>
        if let Some(inner) = self.extract_result_inner_type(type_str) {
            self.collect_referenced_types(&inner, used_types);
            return;
        }

        // Handle Option<T>
        if let Some(inner) = self.extract_option_inner_type(type_str) {
            self.collect_referenced_types(&inner, used_types);
            return;
        }

        // Handle Vec<T>
        if let Some(inner) = self.extract_vec_inner_type(type_str) {
            self.collect_referenced_types(&inner, used_types);
            return;
        }

        // Handle references &T
        if type_str.starts_with('&') {
            let inner = type_str.trim_start_matches('&').trim();
            self.collect_referenced_types(inner, used_types);
            return;
        }

        // If it's not a primitive type, add it to used types
        if !self.is_primitive_type(type_str) {
            used_types.insert(type_str.to_string());
        }
    }

    fn extract_result_inner_type(&self, type_str: &str) -> Option<String> {
        if type_str.starts_with("Result<") && type_str.ends_with('>') {
            let inner = &type_str[7..type_str.len() - 1];
            inner.find(',').map(|comma_pos| inner[..comma_pos].trim().to_string())
        } else {
            None
        }
    }

    fn extract_option_inner_type(&self, type_str: &str) -> Option<String> {
        if type_str.starts_with("Option<") && type_str.ends_with('>') {
            let inner = &type_str[7..type_str.len() - 1];
            Some(inner.trim().to_string())
        } else {
            None
        }
    }

    fn extract_vec_inner_type(&self, type_str: &str) -> Option<String> {
        if type_str.starts_with("Vec<") && type_str.ends_with('>') {
            let inner = &type_str[4..type_str.len() - 1];
            Some(inner.trim().to_string())
        } else {
            None
        }
    }

    fn is_primitive_type(&self, type_str: &str) -> bool {
        matches!(type_str, 
            "String" | "str" | "&str" | 
            "i8" | "i16" | "i32" | "i64" | "i128" | "isize" |
            "u8" | "u16" | "u32" | "u64" | "u128" | "usize" |
            "f32" | "f64" | 
            "bool" | 
            "()" | "number" | "string" | "boolean" | "void"
        )
    }
}

impl Default for BaseGenerator {
    fn default() -> Self {
        Self::new()
    }
}