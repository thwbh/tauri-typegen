pub mod file_writer;
pub mod template_helpers;
pub mod type_conversion;

use crate::analysis::CommandAnalyzer;
use crate::models::{CommandInfo, StructInfo};
use std::collections::HashMap;

/// Common trait for all generators
pub trait BaseBindingsGenerator {
    /// Generate models from Rust commands and structs
    fn generate_models(
        &mut self,
        commands: &[CommandInfo],
        discovered_structs: &HashMap<String, StructInfo>,
        output_path: &str,
        analyzer: &CommandAnalyzer,
    ) -> Result<Vec<String>, Box<dyn std::error::Error>>;

    /// Convert a string to PascalCase
    fn to_pascal_case(&self, s: &str) -> String {
        s.split('_')
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => {
                        first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase()
                    }
                }
            })
            .collect()
    }

    /// Generate file header comment
    fn generate_file_header(&self) -> String {
        let version = env!("CARGO_PKG_VERSION");
        let timestamp = chrono::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Secs, true);

        format!(
            "/**
 * Auto-generated TypeScript types for Tauri commands
 * Generated by tauri-typegen v{}
 * Generated at: {}
 * Do not edit manually - regenerate using: cargo tauri-typegen generate
 */

",
            version, timestamp
        )
    }

    /// Generate command bindings file header
    fn generate_command_file_header(&self) -> String {
        let version = env!("CARGO_PKG_VERSION");
        let timestamp = chrono::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Secs, true);

        format!(
            "/**
 * Auto-generated command bindings for Tauri commands
 * Generated by tauri-typegen v{}
 * Generated at: {}
 * Do not edit manually - regenerate using: cargo tauri-typegen generate
 */

",
            version, timestamp
        )
    }

    /// Generate index file header
    fn generate_index_file_header(&self) -> String {
        let version = env!("CARGO_PKG_VERSION");
        let timestamp = chrono::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Secs, true);

        format!(
            "/**
 * Auto-generated TypeScript bindings for Tauri commands
 * Generated by tauri-typegen v{}
 * Generated at: {}
 * Do not edit manually - regenerate using: cargo tauri-typegen generate
 */

",
            version, timestamp
        )
    }
}

/// Base generator with common functionality
pub struct BaseGenerator {
    pub known_structs: HashMap<String, StructInfo>,
}

impl BaseGenerator {
    pub fn new() -> Self {
        Self {
            known_structs: HashMap::new(),
        }
    }

    /// Filter only the types used by commands
    pub fn collect_used_types(
        &self,
        commands: &[CommandInfo],
        all_structs: &HashMap<String, StructInfo>,
    ) -> HashMap<String, StructInfo> {
        let mut used_types = std::collections::HashSet::new();

        // Collect types from commands
        for command in commands {
            // Add parameter types
            for param in &command.parameters {
                self.collect_referenced_types(&param.rust_type, &mut used_types);
            }
            // Add return type
            self.collect_referenced_types(&command.return_type, &mut used_types);
        }

        // Clone to avoid borrow checker issues
        let initial_types = used_types.clone();

        // Discover nested dependencies (types referenced by the collected types)
        self.discover_nested_dependencies(&initial_types, all_structs, &mut used_types);

        // Filter to only include used types
        all_structs
            .iter()
            .filter(|(name, _)| used_types.contains(*name))
            .map(|(k, v)| (k.clone(), v.clone()))
            .collect()
    }

    /// Recursively discover nested dependencies
    fn discover_nested_dependencies(
        &self,
        initial_types: &std::collections::HashSet<String>,
        all_structs: &HashMap<String, StructInfo>,
        all_types: &mut std::collections::HashSet<String>,
    ) {
        let mut to_process: Vec<String> = initial_types.iter().cloned().collect();
        let mut processed: std::collections::HashSet<String> = std::collections::HashSet::new();

        while let Some(type_name) = to_process.pop() {
            if processed.contains(&type_name) {
                continue;
            }
            processed.insert(type_name.clone());

            if let Some(struct_info) = all_structs.get(&type_name) {
                for field in &struct_info.fields {
                    let mut nested_types = std::collections::HashSet::new();
                    // Use rust_type to collect referenced types
                    self.collect_referenced_types(&field.rust_type, &mut nested_types);

                    for nested_type in nested_types {
                        if !all_types.contains(&nested_type) && all_structs.contains_key(&nested_type)
                        {
                            all_types.insert(nested_type.clone());
                            to_process.push(nested_type);
                        }
                    }
                }
            }
        }
    }

    /// Recursively collect type names from complex types
    pub fn collect_referenced_types(
        &self,
        type_str: &str,
        used_types: &mut std::collections::HashSet<String>,
    ) {
        // Handle Result<T, E>
        if let Some(inner) = self.extract_result_inner_type(type_str) {
            self.collect_referenced_types(&inner, used_types);
            return;
        }

        // Handle Option<T>
        if let Some(inner) = self.extract_option_inner_type(type_str) {
            self.collect_referenced_types(&inner, used_types);
            return;
        }

        // Handle Vec<T>
        if let Some(inner) = self.extract_vec_inner_type(type_str) {
            self.collect_referenced_types(&inner, used_types);
            return;
        }

        // Handle references &T
        if type_str.starts_with('&') {
            let inner = type_str.trim_start_matches('&').trim();
            self.collect_referenced_types(inner, used_types);
            return;
        }

        // If it's not a primitive type, add it to used types
        if !self.is_primitive_type(type_str) {
            used_types.insert(type_str.to_string());
        }
    }

    fn extract_result_inner_type(&self, type_str: &str) -> Option<String> {
        if type_str.starts_with("Result<") && type_str.ends_with('>') {
            let inner = &type_str[7..type_str.len() - 1];
            inner
                .find(',')
                .map(|comma_pos| inner[..comma_pos].trim().to_string())
        } else {
            None
        }
    }

    fn extract_option_inner_type(&self, type_str: &str) -> Option<String> {
        if type_str.starts_with("Option<") && type_str.ends_with('>') {
            let inner = &type_str[7..type_str.len() - 1];
            Some(inner.trim().to_string())
        } else {
            None
        }
    }

    fn extract_vec_inner_type(&self, type_str: &str) -> Option<String> {
        if type_str.starts_with("Vec<") && type_str.ends_with('>') {
            let inner = &type_str[4..type_str.len() - 1];
            Some(inner.trim().to_string())
        } else {
            None
        }
    }

    fn is_primitive_type(&self, type_str: &str) -> bool {
        matches!(
            type_str,
            "String"
                | "str"
                | "&str"
                | "i8"
                | "i16"
                | "i32"
                | "i64"
                | "i128"
                | "isize"
                | "u8"
                | "u16"
                | "u32"
                | "u64"
                | "u128"
                | "usize"
                | "f32"
                | "f64"
                | "bool"
                | "()"
                | "number"
                | "string"
                | "boolean"
                | "void"
        )
    }
}

impl Default for BaseGenerator {
    fn default() -> Self {
        Self::new()
    }
}
