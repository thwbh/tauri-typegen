use std::fs;
use std::path::Path;

/// Utility for writing generated TypeScript files with consistent patterns
pub struct FileWriter {
    output_path: String,
    generated_files: Vec<String>,
}

impl FileWriter {
    pub fn new(output_path: &str) -> Result<Self, Box<dyn std::error::Error>> {
        fs::create_dir_all(output_path)?;
        Ok(Self {
            output_path: output_path.to_string(),
            generated_files: Vec::new(),
        })
    }

    /// Write a TypeScript file with the given content
    pub fn write_typescript_file(
        &mut self,
        filename: &str,
        content: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let file_path = format!("{}/{}", self.output_path, filename);
        fs::write(&file_path, content)?;
        self.generated_files.push(filename.to_string());
        Ok(())
    }

    /// Write the types.ts file
    pub fn write_types_file(&mut self, content: &str) -> Result<(), Box<dyn std::error::Error>> {
        self.write_typescript_file("types.ts", content)
    }

    /// Write the commands.ts file  
    pub fn write_commands_file(&mut self, content: &str) -> Result<(), Box<dyn std::error::Error>> {
        self.write_typescript_file("commands.ts", content)
    }

    /// Write the index.ts file
    pub fn write_index_file(&mut self, content: &str) -> Result<(), Box<dyn std::error::Error>> {
        self.write_typescript_file("index.ts", content)
    }

    /// Write the schemas.ts file (for zod generator)
    pub fn write_schemas_file(&mut self, content: &str) -> Result<(), Box<dyn std::error::Error>> {
        self.write_typescript_file("schemas.ts", content)
    }

    /// Get the list of generated files
    pub fn get_generated_files(&self) -> &[String] {
        &self.generated_files
    }

    /// Get the output path
    pub fn get_output_path(&self) -> &str {
        &self.output_path
    }

    /// Generate a standard index file that exports from the generated files
    pub fn generate_standard_index(&self, files_to_export: &[&str]) -> String {
        let version = env!("CARGO_PKG_VERSION");
        let timestamp = chrono::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Secs, true);

        let mut content = format!(
            "/**
 * Auto-generated TypeScript bindings for Tauri commands
 * Generated by tauri-plugin-typegen v{}
 * Generated at: {}
 * Do not edit manually - regenerate using: cargo tauri-typegen generate
 */

",
            version, timestamp
        );

        for file in files_to_export {
            let module_name = file.trim_end_matches(".ts");
            content.push_str(&format!("export * from './{}';\n", module_name));
        }
        content.push('\n');

        content
    }

    /// Create directory if it doesn't exist
    pub fn ensure_directory_exists(path: &str) -> Result<(), Box<dyn std::error::Error>> {
        fs::create_dir_all(path)?;
        Ok(())
    }

    /// Check if a file exists in the output directory
    pub fn file_exists(&self, filename: &str) -> bool {
        let file_path = format!("{}/{}", self.output_path, filename);
        Path::new(&file_path).exists()
    }

    /// Delete a file if it exists (useful for cleanup)
    pub fn delete_file(&self, filename: &str) -> Result<(), Box<dyn std::error::Error>> {
        let file_path = format!("{}/{}", self.output_path, filename);
        if Path::new(&file_path).exists() {
            fs::remove_file(&file_path)?;
        }
        Ok(())
    }

    /// Get the full path to a file in the output directory
    pub fn get_file_path(&self, filename: &str) -> String {
        format!("{}/{}", self.output_path, filename)
    }
}
